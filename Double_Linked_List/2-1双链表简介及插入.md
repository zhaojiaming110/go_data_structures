---
title: "2-1双链表简介及插入"
date: 2019-11-10T23:01:23+08:00
tags: ["Double Linked List"]
categories: ["Date Structures With Go"]
author: "Beyourself"
menu:
  main:
    parent: "Date Structures With Go"
    weight: 101
---

在前面的一些文章[Singly Linked List](https://beuself.xyz/tags/singly-linked-list/)我们介绍了单链表，接下来我们继续学习双链表（Double Linked List 简称DLL）。

#### 介绍

一个双链表包含一个额外的指针，通常称为前指针，与单链表的数据及后指针构成。

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9rpwev1mcj30p7056t8i.jpg)

#### 节点表示

以下是Go语言中双链表节点的表示：

```go
type Node struct {
	Data int
	Prev *Node
	Next *Node
}
```

#### 优缺点

以下是双链表相对于单链表的优缺点

##### 优点

- 双链表可以向前和向后进行遍历。
- 如果给出了要删除的节点的指针，则双链表的删除会更有效。
- 双链表可以在给定节点之前快速插入一个新的节点。
- 在单链表中要删除一个节点，需要指向前一个节点的指针。为了获得该节点的指针，常常需要去遍历链表；在双链表中，我们可以使用当前节点的前指针获取先前指针的节点。

##### 缺点

- 双链表的每个节点都需要额外的空间才能存储先前的指针。
- 所有操作都需要事先保留一个额外的指针。例如：
    - 在插入时，我们需要同时修改前一个指针和下一个指针。
    - 在以下用于不同位置插入的函数中，我们需要1个或2个步骤来设置先前的指针。

#### 插入节点

我们可以通过四种方法添加节点：

- 在双链表的前面
- 在给定节点之后
- 在双链表的末尾
- 在给定节点之前

#### 代码实现

##### 在双链表的最前面插入节点

新节点总是添加到给定链表**的最前面**。新添加的节点成为DLL的新负责人。例如，如果给定的链表为10->15->20->25，并且我们在前面添加了项5，则链接列表将变为5->10->15->20->25。让我们将添加到列表前面的函数称为push()。push()必须接受一个指向头指针的指针，因为push必须改变头指针去指向新的节点（或者可以返回一个改变后的头指针）。
![](https://tva1.sinaimg.cn/large/006tNbRwly1g9rqmcoc8kj30p7056t8i.jpg)

###### 具体步骤：

- 创建新的节点，并初始化。
- 使头结点的前指针指向新节点。
- 返回新的头结点的指针。

###### 代码

```go
// 在双链表前插入一个新的节点
func (head *Node) push(new_date int) *Node {
	// 1.创建新节点并初始化节点
	new_node := &Node{new_date, null, head}
	if *head == (Node{}) {
		new_node.Next = nil
	} else {
		// 2.使头结点的前指针指向新节点
		head.Prev = new_node
	}
	// 返回新的头指针
	return new_node
}
```

上述操作比在单链表最前面插入节点多了更改原头结点的Prev

##### 在给定节点之后添加节点

给一个指向给定节点的指针，然后在给定节点之后添加新的节点
![](https://tva1.sinaimg.cn/large/006tNbRwly1g9rydo1wqfj30sf08ja9w.jpg)

###### 具体步骤：

- 检查给定的节点是否为空
- 创建新节点，并初始化
- 修改插入给定节点之后的前节点的Next，后节点的Pre

###### 代码


```go
func (pre *Node) insertafter(new_date int) {
	// 1.检查给定节点是否为空节点
	if *pre == (Node{}) {
		fmt.Println("The given previous node is null")
		return
	}
	// 2.创建新节点并初始化
	new_node := &Node{new_date, pre, pre.Next}
	// 3.改变前置节点的next，后置节点的prev
	pre.Next = new_node
	if new_node.Next != nil {
		new_node.Next.Prev = new_node
	}
}
```

上述步骤比在单链表给定节点之后的操作多了修改前后节点的Next、Prev

##### 在链表末尾添加节点

总是在给定链表的最后一个节点之后添加新节点。例如，如果给定的DLL是5->10->15->20->25，而我们在末尾添加了第30个项目，则DLL变为5->10->15->20->25->30。
由于通常由链表首表示链表，因此我们必须遍历该链表直到结尾，然后更改最后一个节点的Next使其指向新节点。

###### 具体步骤：

- 创建新的节点，并且初始化
- 如果给定节点为空，则新`new_node.Prev=nil`
- 更改最后节点的`Next`，`new_node.Prev`为最后节点的地址。

###### 代码


```go
// 在双链表末尾添加一个新的节点.
func appendEnd(head **Node, new_date int) {
	new_node := &Node{Data: new_date, Next: nil}
	temp := *head

	// 给定链表为空链表的情况
	if **head == (Node{}) {
		new_node.Prev = nil
		*head = new_node
		return
	}

	for temp.Next != nil {
		temp = temp.Next
	}

	temp.Next = new_node
	new_node.Prev = temp
}
```

##### 在给定节点之前添加一个新的节点

###### 代码

```go
// 在给定节点之前添加一个新的节点
func insertBefore(head **Node, next_node *Node, new_date int) {
	if *next_node == (Node{}) {
		fmt.Println("The given next_node cannot be NULL")
		return
	}

	// 创建新节点
	new_node := &Node{new_date, next_node.Prev, next_node}
	// 更改next_node.Prev
	next_node.Prev = new_node
	if new_node.Prev == nil {
		*head = new_node
	} else {
		new_node.Prev.Next = new_node
	}
}
```

